\documentclass[aspectratio=169]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{minted}
\usepackage{appendixnumberbeamer}
\usepackage{hyperref}
\usepackage{macosbox}
\usepackage{codebox}
\usepackage{apple_emoji}
\usepackage[normalem]{ulem}
\usepackage{forest}
% \usepackage[texcoord,grid,gridunit=mm,gridcolor=red!20,subgridcolor=gray!10]{eso-pic}

\usemintedstyle{colorful}
\usecodeboxmintedstyle{zenburn}
\newminted{cl}{autogobble,breaklines,escapeinside=||}
\setmintedcodebox{clcode}{title=Common Lisp,icon=\(\mathbf{\lambda}\),compact}
\newminted[smallclcode]{cl}{autogobble,breaklines,escapeinside=||,fontsize=\scriptsize}
\setmintedcodebox{smallclcode}{title=Common Lisp,icon=\(\mathbf{\lambda}\),compact}
\newminted[hlclcode]{cl}{autogobble,breaklines,escapeinside=||}
\setmintedcodebox{hlclcode}{headless,compact}

\usetheme{avalon}
\def\avalonprogressbar{1}
\def\avalondarkmintedstyle{monokai}%{zenburn}

\title{Implementing Baker's \texttt{SUBTYPEP} decision procedure\vspace*{-5mm}}
% \subtitle{European Lisp Symposium}
\date{April 1st, 2019}
\author{LÃ©o Valais}
\institute{European Lisp Symposium}

\titlegraphic{\includegraphics[scale=.2]{lrde_epita.png}}

\renewcommand\code[1]{\texttt{#1}}
\newcommand\rarr{\ensuremath{\rightarrow}}
\newcommand\Rarr{\ensuremath{\Rightarrow}}
\newcommand\plholder[1]{\ensuremath{\langle {#1} \rangle}}
\newcommand\emoji[2][\tiny]{{#1#2}}
\newcommand\plus{{\color{watchOS-blue}\faPlus}}
\newcommand\minus{{\color{watchOS-red}\faMinus}}
\newcommand\good{{\color{watchOS-green}\faCheck}}
\newcommand\bad{{\color{watchOS-red}\faClose}}
\newcommand\tgood{{\color{watchOS-purple}\faThumbsOUp}}
\newcommand\tbad{{\color{watchOS-red}\faThumbsODown}}

\begin{document}

\begin{frame}
\titlepage{}
\end{frame}

\section{The Common Lisp type system}

\newenvironment{sectionframe}[1]{%
  \begin{frame}[standout]
    \centering
    \Huge
    {\bf #1}

    {\usebeamercolor[bg]{secondary color}\noindent\sout{\hfill}}
    \bigskip

    \large
  }{\end{frame}}

\begin{sectionframe}{Introduction}
  Common Lisp type system, \code{subtypep} \\\& Baker's decision procedure
\end{sectionframe}

\begin{frame}
  \frametitle{The Common Lisp type system}
  \begin{itemize}
  \item Types \rarr{} sets, subtypes \rarr{} subsets
  \item S-expression based, inductive Domain-Specific Language \rarr{} \emph{type specifiers}
  \item Examples
    \begin{itemize}
    \item Atomic \rarr{} \code{string}, \code{integer}, \code{my-class}, \dots
    \item Compound form
      \begin{itemize}
      \item \code{(or string number)} $\equiv \code{string} \cup \code{number}$
      \item \code{(unsigned-byte 10)} $\equiv \{0, 1, \cdots, 2^{10} - 1\}$
      \item \code{(array real (3 3))} $\equiv \mathcal M_{3,3}(\mathbb R)$
      \item Many more!
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Use case}
  \begin{columns}
    \column{0pt}
    \column{.6\paperwidth}
    \[
      \forall M \in \mathcal M_{3,3}(\mathbb R), tr(M) = \sum_{i=1}^3 M_{i,j}
    \]
\begin{clcode}
(defun tr (M)
  (declare (type (array real (3 3)) M))
  (+ (aref M 0 0)
     (aref M 1 1)
     (aref M 2 2)))
\end{clcode}

    \column<2>{.3\paperwidth}
    \begin{itemize}
    \item Type checking
    \item Value checking
    \item Compiler optimization
    \item Documentation
    \end{itemize}
  \end{columns}
\end{frame}

\section{\code{subtypep}}
\subsection{Problems}

\begin{frame}[fragile]
  \frametitle{What about subtyping?}
  \begin{itemize}
  \item \code{(subtypep \plholder A \plholder B)} $\equiv A \subseteq B?$
  \item Predicate function
  \end{itemize}

  \medskip

  \begin{overprint}[\textwidth]
    \onslide<2>
    \begin{mintedcodebox}[title=Quite easy,compact,icon=\(\lambda\)]
\begin{minted}{cl}
(subtypep '(and integer
                (not float))
          '(or number string))
\end{minted}
    \end{mintedcodebox}

    \onslide<3>
    \begin{mintedcodebox}[title=Not that easy after all\dots,compact,icon=\(\lambda\)]
\begin{minted}{cl}
(subtypep '(or my-class string (integer 0 (1024)))
          '(or super-class
               (array * 1)
               (unsigned-byte 10)))
\end{minted}
    \end{mintedcodebox}

    \onslide<4->
    \begin{mintedcodebox}[title=\textnormal{\it ``Oh dear, we are in trouble''
        \emoji{ðŸ˜¢}},compact,icon=\(\lambda\)]
\begin{minted}{cl}
(subtypep '(or string
               my-class
               (and integer
                    (not (unsigned-byte 10)))
               (member 3.14 2.71))
          '(and (array * (* * 8 *))
                bit-vector
                (not (eql :some-keyword))))
\end{minted}
    \end{mintedcodebox}
  \end{overprint}

  \begin{popup}{.75}
    \onslide<5>
    \begin{macosbox}{}
      \begin{itemize}
      \item Type specifiers arbitrarily deep
      \item May take a while to answer\dots
      \end{itemize}

      \begin{alertblock}{Problem \#1 --- complex input}
        Arbitrarily complex input type specifiers
      \end{alertblock}
    \end{macosbox}
  \end{popup}
\end{frame}

\begin{frame}
  \frametitle{\code{satisfies} type specifier}
  \begin{itemize}
  \item \code{(satisfies \plholder{predicate})} $\equiv \left\{x \mid
      predicate(x)\right\}$
  \item \code{(satisfies oddp)} \rarr{} all odd numbers
    \pause
  \item \code{(subtypep '(satisfies oddp) '(satisfies evenp))}
    \pause
  \item \alert{\code{(subtypep '(satisfies \plholder F) '(satisfies
        \plholder G))}}
    \begin{itemize}
    \item arbitrary predicates $F$ and $G$
    \end{itemize}
  \item  halting problem \rarr{} \code{subtypep} \emph{cannot} even answer
    \emoji{ðŸ˜±}
  \end{itemize}

  \pause
  \begin{alertblock}{Problem \#2 --- undecidability}
    \code{Subtypep} cannot answer for some type specifiers
  \end{alertblock}
\end{frame}

\subsection{Definition}

\begin{frame}
  \frametitle{\code{subtypep}}
  \[
    \code{(subtypep \plholder{A} \plholder{B})} =
    \begin{cases}
      \code{(T T)} &\rarr{} A \subseteq B \\
      \code{(NIL T)} &\rarr{} A \not\subseteq B \\
      \code{(NIL NIL)} &\rarr{} \text{\alt<1>{``I can't answer''}{%
          \alert<2>{``I give up, sorry \emoji{ðŸ¤•}''}}}
    \end{cases}
  \]

  \begin{itemize}
  \item<1-> \code{(NIL NIL)} encodes \alt<1>{undecidability}
    {\sout{undecidability}\alert<2>{``input too complex''}}
  \item<3> Lack of reliability
  \item<3> Painful limit for some applications
    \begin{itemize}
    \item Newton's regular type expressions
    \item Newton's optimized \code{typecase} implementation
    \end{itemize}
  \end{itemize}
\end{frame}

\section{Baker's decision procedure}
\subsection{Presentation}

\begin{frame}
  \frametitle{Baker's decision procedure}
  \setbeamercovered{highly dynamic}
  \begin{columns}
    \column{.45\paperwidth}
    \begin{itemize}
    \item[\plus] focus on result accuracy
    \item[\plus] \emph{never} returns \code{(NIL NIL)} uselessly
      \pause
    \item[\minus] paper difficult to read
    \item[\minus] not exhaustive
    \item[\minus] very few solutions about \code{satisfies}
    \end{itemize}

    \pause
    \column{.45\paperwidth}
    \begin{itemize}
    \item[\plus] efficiency% \rarr{} comparable to ``existing'' implementations
    \item[\minus] \emph{not} open source
      \pause
    \item[\plus] Divide and Conquer
    \item[\minus] exponential complexity (theoretical)
    \end{itemize}
  \end{columns}
\end{frame}

\begin{sectionframe}{Application}
  % Step by step application for some simple example
  Step by step execution of \code{subtypep}
\end{sectionframe}

\begin{frame}[fragile]
  \frametitle{The problem}
  \begin{itemize}
  \item Serialize CLOS instances \rarr{} JSON
  \item Automatic JSON object construction
  \end{itemize}

  \begin{columns}
    \column{.55\paperwidth}
\begin{clcode}
(defclass point ()
  ((x :type number
      :initarg :x)
   (y :type number
      :initarg :y)
   (name :type string
         :initarg :name))
  (:metaclass json-serializable))

(json-serialize (make-instance 'point :x -10 :y 3.2 :name "A1"))
\end{clcode}

    \pause

    \column{.4\paperwidth}
  \begin{mintedcodebox}[title=JSON serialization,icon=\faOpera,compact]
\begin{minted}{json}
{
  "X": -10,
  "Y": 3.2,
  "NAME": "A1"
}
\end{minted}
  \end{mintedcodebox}
\end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{CLOS setup}
\begin{clcode}
(defclass json-serializable (standard-class)
  ())

(defmethod validate-superclass
    ((class json-serializable) (superclass standard-class))
  t)
(defmethod validate-superclass
    ((class standard-class) (superclass json-serializable))
  t)

(defgeneric json-serialize (instance))
\end{clcode}

  \pause
  \begin{itemize}
  \item No restriction on subclassing
  \item But restrictions on existence!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\code{json-serializable} existence condition}
  \begin{columns}
    \column{.5\textwidth}
    \begin{itemize}
    \item Slots
      \begin{itemize}
      \item[\tgood] names \rarr{} symbols
      \item[\tbad] values \rarr{} virtually \emph{any type}
      \end{itemize}
    \item<3-> Types of slots \rarr{} $u_1, u_2, \dots, u_n$
      \begin{itemize}
      \item $u_i \subseteq \code{json}$
      \item[\Rarr{}] \code{(subtypep $u_i$ 'json)}
      \end{itemize}
    \item<3-> Trigger compile-time error
  \end{itemize}

    \column<2->{.5\textwidth}
\begin{clcode}
(deftype json ()
  '(or number
       string
       (member :true
               :false
               :null)
       (and symbol
            (not keyword))
       list
       hash-table))
\end{clcode}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\code{json-serializable} existence check}
\begin{clcode}
(defun json-compatible-class-p (class)
  (let* ((slots (class-slots class))
         (types (mapcar #'slot-definition-type slots)))
    (every (lambda (slot-type)
             (subtypep slot-type 'json))
           types)))

(defmethod initialize-instance ((class json-serializable)
                                &rest args)
  (let ((class (call-next-method)))
    (closer-mop:ensure-finalized class nil)
    (unless (json-compatible-class-p class)
      (error "class ~a is not JSON-compatible" class))
    cls))
\end{clcode}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\code{employee} class}
\begin{clcode}
(deftype position-type () '(member :ceo :dev :sales))

(defclass employee ()
  ((name :type (or string
                   (and symbol
                        (not keyword))
                   unsigned-byte))
   (position :type position-type)
   (previous-position :type (and position-type
                                 (not (eql :ceo)))))
  (:metaclass json-serializable))
\end{clcode}

  \pause
  \begin{itemize}
  \item 2 \code{subtypep} calls \rarr{} one per slot
  \end{itemize}
\end{frame}

\begin{sectionframe}{Pre-processing}
  Simplifying the problem
\end{sectionframe}

\begin{frame}[fragile]
  \frametitle{\code{employee.name}}
  \begin{columns}
    \column{.60\textwidth}
  \begin{mintedcodebox}[title=\code{name}'s type verification,icon=\(\lambda\),compact]
    \begin{overprint}
      \onslide<1>
\begin{minted}{cl}
(subtypep '(or string
               (and symbol
                    (not keyword))
               unsigned-byte)
          'json)
\end{minted}

      \onslide<2->
\begin{minted}{cl}
(subtypep '(or string
               (and symbol
                    (not keyword))
               unsigned-byte)
          '(or number
               string
               (member :true
                       :false
                       :null)
               (and symbol
                    (not keyword))
               list
               hash-table))
\end{minted}
    \end{overprint}
  \end{mintedcodebox}

    \column{.40\textwidth}
    \begin{itemize}
    \item<2-> alias expansion
      \begin{itemize}
      \item implementation dependant feature
      \item \code{sb-ext:typexpand}
      \end{itemize}
    \item<3-> more preprocessing!
      \begin{itemize}
      \item syntactic sugar elimination
      \item \alt<3>{numeric types specific actions}{\sout{numeric types specific
            actions}}
      \end{itemize}
    \item<5-> splitting
      \begin{itemize}
      \item ``litteral'' types
      \item ``numeric'' types
      \end{itemize}
    \item<6-> subtyping equivalence
    \end{itemize}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Problem reformulation} % \emoji[\normalsize]{ðŸ”ª}
  \newminted[localcl]{cl}{fontsize=\scriptsize}

  \begin{columns}
    \column{.55\textwidth}
    \begin{mintedcodebox}[title=Litteral types splitting,compact,icon=\faQuoteLeft]
      \begin{overprint}
        \onslide<1>
\begin{localcl}
(subtypep '(or string
               (and symbol
                    (not keyword))
               unsigned-byte)
          '(or number
               string
               (member :true
                       :false
                       :null)
               (and symbol
                    (not keyword))
               list
               hash-table))
\end{localcl}

        \onslide<2->
\begin{localcl}
(subtypep '(or string
               (and symbol
                    (not keyword))
               NIL)
          '(or NIL
               string
               (member :true
                       :false
                       :null)
               (and symbol
                    (not keyword))
               list
               hash-table))
\end{localcl}
      \end{overprint}
    \end{mintedcodebox}

    \column{.55\textwidth}
    \begin{mintedcodebox}[title=Numeric types splitting,compact,icon=\faCalculator]
      \begin{overprint}
        \onslide<1-2>
\begin{localcl}
(subtypep '(or string
               (and symbol
                    (not keyword))
               unsigned-byte)
          '(or number
               string
               (member :true
                       :false
                       :null)
               (and symbol
                    (not keyword))
               list
               hash-table))
\end{localcl}

        \onslide<3->
\begin{localcl}
(subtypep '(or NIL
               (and NIL
                    (not NIL))
               unsigned-byte)
          '(or number
               NIL
               NIL
               (and NIL
                    (not NIL))
               NIL
               NIL))
\end{localcl}
      \end{overprint}
    \end{mintedcodebox}
  \end{columns}

  \begin{popup}{.65}
    % \vspace*{-2em}
    \onslide<4-5>
    \begin{mintedcodebox}[headless,compact]
\begin{localcl}
(and (subtypep '(or string
                    (and symbol
                         (not keyword))
                    NIL)
               '(or NIL
                    string
                    (member :true :false :null)
                    (and symbol
                         (not keyword))
                    list
                    hash-table))
     (subtypep '(or NIL
                    (and NIL
                         (not NIL))
                    unsigned-byte)
               '(or number
                    NIL
                    NIL
                    (and NIL
                         (not NIL))
                    NIL
                    NIL)))
\end{localcl}
    \end{mintedcodebox}
  \end{popup}

  \begin{popup}{.75}
    \onslide<5>
    \begin{macosbox}{Subtyping equivalence}
      \begin{itemize}
      \item $A \subseteq B \Leftrightarrow A \cap \overline B
        = \emptyset$
      \item {\small\code{(subtypep \plholder A \plholder B)} $\equiv$
          \code{(subtypep '(and \plholder A (not \plholder B)) nil)}}
      \end{itemize}
    \end{macosbox}
  \end{popup}

  \begin{popup}{.65}
    \vspace*{-2.5em}
    \onslide<6>
    \begin{mintedcodebox}[headless,compact]
\begin{localcl}
(and (subtypep '(AND (or string
                         (and symbol
                              (not keyword))
                         NIL)
                     (NOT (or NIL
                              string
                              (member :true :false :null)
                              (and symbol
                                   (not keyword))
                              list
                              hash-table)))
               NIL)
     (subtypep '(AND (or NIL
                         (and NIL
                              (not NIL))
                         unsigned-byte)
                     (NOT (or number
                              NIL
                              NIL
                              (and NIL
                                   (not NIL))
                              NIL
                              NIL)))
               NIL))
\end{localcl}
    \end{mintedcodebox}
  \end{popup}

  \begin{popup}{.7}
    \vspace*{-2em}
    \onslide<7->
    \begin{mintedcodebox}[headless,compact]
\begin{localcl}
(and (NULL-LITERAL-TYPE-P '(AND (or string
                                    (and symbol
                                         (not keyword))
                                    NIL)
                                (NOT (or NIL
                                         string
                                         (member :true :false :null)
                                         (and symbol
                                              (not keyword))
                                         list
                                         hash-table))))
     (NULL-NUMERIC-TYPE-P '(AND (or NIL
                                    (and NIL
                                         (not NIL))
                                    unsigned-byte)
                                (NOT (or number
                                         NIL
                                         NIL
                                         (and NIL
                                              (not NIL))
                                         NIL
                                         NIL)))))
\end{localcl}
    \end{mintedcodebox}
  \end{popup}

  \begin{popup}{.75}
    \onslide<8>
    \begin{macosbox}{Preprocessing summary}
      \begin{itemize}
      \item alias (\code{deftype}) expansion
      \item splitting across ``type kingdoms''
      \item $A \subseteq B \Leftrightarrow A \cap \overline B = \emptyset$
      \item \emph{specialized sub-procedures}
        \begin{itemize}
        \item \code{null-literal-type-p}
        \item \sout{\code{null-numeric-type-p}}
        \end{itemize}
      \end{itemize}
    \end{macosbox}
  \end{popup}
\end{frame}

\begin{sectionframe}{Literal types specialized sub-procedure}
  Primitive types, \code{member} type specifiers, CLOS classes
\end{sectionframe}

\begin{frame}
  \frametitle{\textit{The Matrix}${}^{\text{\faTrademark}}$}
  \begin{block}{Some\only<4->{ (unrealistic \emoji{ðŸ™ˆ})} assumptions}
    \begin{itemize}
    \item We can enumerate all Common Lisp values \rarr{} $e_1, e_2, \dots,
      e_\omega$
    \item<2-> We can enumerate all combinations of these \rarr{} $u_1, u_2,
      \dots, u_\omega$
      \begin{itemize}
      \item<3-> all Common Lisp types!
      \end{itemize}
    \end{itemize}
  \end{block}

  \begin{columns}
    \column<5->{.3\textwidth}
    \begin{align*}
      \emptyset &= \{\}\quad\text{(a.k.a. \code{nil})}\\
      u_1 &= \{e_1, e_3, e_4\} \\
      u_2 &= \{e_1\} \\
          &\vdots\\
      u_\omega &= \{e_2,e_4,\cdots\}
    \end{align*}

    \column<6->{.7\textwidth}
    \[ e_i \in u_j \Leftrightarrow \mathcal M_{j,i} = 1 \]
    \[
      \bordermatrix{
        &e_1   &e_2   &e_3   &e_4   &\cdots&e_\omega \cr
        \mathcal B_\emptyset &0     &0     &0     &0     &\cdots&0       \cr
        \mathcal B_1     &1     &0     &1     &1     &\cdots&0       \cr
        \mathcal B_2     &1     &0     &0     &0     &\cdots&0       \cr
        \vdots  &\vdots&\vdots&\vdots&\vdots&\ddots&\vdots  \cr
        \mathcal B_\omega&0     &1     &0     &1     &\cdots&0
      }
    \]
  \end{columns}

  \begin{popup}{.75}
    \vspace*{-9em}
    \onslide<7->
    \begin{macosbox}{Properties}
      \begin{itemize}
      \item $\mathcal B_i$ \rarr{} bit-vector representing the type $u_i$
      \item $u_i \cup u_j$ \rarr{} $\mathcal B_i \vee \mathcal B_j$ (bitwise)
      \item $u_i \cap u_j$ \rarr{} $\mathcal B_i \wedge \mathcal B_j$ (bitwise)
      \item $\overline{u_i}$ \rarr{} $\neg\mathcal B_i$ (bitwise)
      % \item<8> $u_i \subseteq u_j \Leftrightarrow \mathcal B_i \wedge \neg
      %   \mathcal B_j = \mathcal B_\emptyset\quad(= \mathcal B_{\code{nil}})$
      \end{itemize}
    \end{macosbox}
  \end{popup}
\end{frame}

\begin{frame}[standout]
  \frametitle{\code{null-literal-type-p}}
  \begin{align*}
    \code{(subtypep \plholder{u_i} \plholder{u_j})} &\equiv u_i \subseteq u_j \\
                                                    &\Leftrightarrow u_i \cap \overline{u_j} = \emptyset\\
                                                    &\equiv \code{(null-literal-type-p '(and \plholder{u_i} (not \plholder{u_j})))} \\
                                                    &\Leftrightarrow \mathcal B_i \wedge \neg \mathcal B_j = \mathcal B_\emptyset
  \end{align*}

  \pause
  \begin{itemize}
  \item All about matrix lookups \& bitwise operations on bit-vectors
  \item Very fast, but\dots
    \pause
  \item \dots still an \emph{infinite} matrix! \emoji{ðŸ˜”}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Getting finite}
  \begin{columns}
    \column{.5\textwidth}
    \begin{overprint}
      \onslide<1>
      \[
        \bordermatrix{
          &e_1   &e_2   &e_3   &e_4   &\cdots&e_N &\cdots \cr
          \mathcal B_\emptyset &0     &0     &0     &0     &\cdots&0&\cdots       \cr
          \mathcal B_1     &1     &0     &1     &1     &\cdots&0&\cdots       \cr
          \mathcal B_2     &1     &0     &0     &0     &\cdots&0&\cdots       \cr
          \vdots  &\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\ddots  \cr
          \mathcal B_M&0     &1     &0     &1     &\cdots&0&\cdots \cr
          \vdots  &\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\ddots  \cr
        }
      \]

      \onslide<2>
      \[
        \bordermatrix{
          &e_1   &e_2   &e_3   &e_4   &\cdots&e_N &\cdots \cr
          \mathcal B_\emptyset &0     &0     &0     &0     &\cdots&0&\cdots       \cr
          \mathcal B_1     &1     &0     &1     &1     &\cdots&0&\cdots       \cr
          \mathcal B_2     &1     &0     &0     &0     &\cdots&0&\cdots       \cr
          \vdots  &\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\ddots  \cr
          \mathcal B_M&0     &1     &0     &1     &\cdots&0&\cdots \cr
        }
      \]

      \onslide<3>
      \[
        \bordermatrix{
          &e_1   &e_2   &e_3   &e_4   &\cdots&e_N \cr
          \mathcal B_\emptyset &0     &0     &0     &0     &\cdots&0\cr
          \mathcal B_1     &1     &0     &1     &1     &\cdots&0\cr
          \mathcal B_2     &1     &0     &0     &0     &\cdots&0\cr
          \vdots  &\vdots&\vdots&\vdots&\vdots&\ddots&\vdots\cr
          \mathcal B_M&0     &1     &0     &1     &\cdots&0\cr
        }
      \]

      \onslide<4>
      \[
        \bordermatrix{
          &r_1   &r_2   &r_3   &r_4   &\cdots&r_N \cr
          \mathcal B_\emptyset &0     &0     &0     &0     &\cdots&0\cr
          \mathcal B_1     &1     &0     &1     &1     &\cdots&0\cr
          \mathcal B_2     &1     &0     &0     &0     &\cdots&0\cr
          \vdots  &\vdots&\vdots&\vdots&\vdots&\ddots&\vdots\cr
          \mathcal B_M&0     &1     &0     &1     &\cdots&0\cr
        }
      \]
    \end{overprint}
    \column{.5\textwidth}
    \begin{itemize}
    \item<2-> Types ($u_k$ and associated $\mathcal B_k$)
      \begin{itemize}
      \item only those in \code{subtypep} call
      \item \code{nil} is always involved (somehow)
      \end{itemize}
    \item<3-> Values ($e_k$)
      \begin{itemize}
      \item only \emph{sufficiently many}
      \item distinguish each type from the others
      \end{itemize}
    \item<4-> Not just ``values'' \rarr{} \emph{representative} elements
    \end{itemize}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Back to our problem}
  \newcommand\bv[1]{\ensuremath{\mathcal B_{\code{\scriptsize#1}}}}
% \begin{clcode}
% (null-literal-type-p '(and (or string
%                                (and symbol
%                                     (not keyword))
%                                nil)
%                             (not (or nil
%                                      string
%                                      (member :true :false :null)
%                                      (and symbol
%                                           (not keyword))
%                                      list
%                                      hash-table))))
% \end{clcode}
  \begin{columns}
    \column{.5\textwidth}
\begin{smallclcode}
(null-literal-type-p
 '(and (or string
           (and symbol
                (not keyword))
           nil)
       (not (or nil
                string
                (member :true
                        :false
                        :null)
                (and symbol
                     (not keyword))
                list
                hash-table))))
\end{smallclcode}

    \column<2->{.5\textwidth}
    \begin{itemize}
    \item<2-> Matrix setup
      \begin{itemize}
      \item primitive types known at compile-time
      \item manual representative choice
      \end{itemize}
    \item<4-> Lookup bit-vectors \& translate logic operators
      % \begin{itemize}
      % \item with care to avoid misrepresentation \emoji{ðŸ˜›}
      % \end{itemize}
    \item<11-> \code{(member \plholder a \plholder b)} type
      specifier bit-vector
      \begin{enumerate}
      \item register $a$ and $b$ as representatives
      \item \(
        \bv{(member \plholder a \plholder b)} =
        \bv{$\{a\}$} \vee \bv{$\{b\}$}
        \)
      \end{enumerate}
    \item<13-> Eventually reduces to \bv{nil}
    \item<13-> \code{null-literal-type-p} returns true
    \end{itemize}
  \end{columns}

  \begin{popup}{.85}
    \onslide<5-10,12>
    \begin{macosbox}{Bit-vector expression reduction}
      \centering
      \newcommand\inter{\alt<5>{$\cap$}{$\wedge$}}
      \newcommand\union{\alt<5>{$\cup$}{$\vee$}}
      \newcommand\compl{\alt<5>{$\phantom{ }^C$}{$\neg$}}
      \newcommand\co[1]{\alt<5>{\code{#1}}{\bv{#1}}}
      \begin{forest}
        [\inter
         [\union
          [\co{string}]
          [\inter
           [\co{symbol}]
           [\compl [\co{keyword}]]]
          [\co{nil}]]
         [\compl
          [\union
           [\co{nil}]
           [\co{string}]
           [\alert<7>{\co{MEMBER}}]
           [\inter [\co{symbol}] [\compl [\co{keyword}]]]
           [\co{list}]
           [\co{hash-table}]]]]
      \end{forest}
    \end{macosbox}
  \end{popup}

  \begin{popup}{.80}
    \onslide<3,8-9>
    \begin{macosbox}{The Matrix}
      \newcommand\repr[1]{\code{#1}}%{\rotatebox{45}{\code{#1}}}
      \begin{overprint}
        \onslide<3,8>
        \[
          \bordermatrix{
            &\repr{t}&\repr{nil}&\repr{sym}&\repr{"str"}&\cdots&\repr{\scriptsize(l i s t)}\cr
            \bv{nil}     &0     &0     &0     &0     &\cdots&0\cr
            \bv{t} &1     &1     &1     &1     &\cdots&1\cr
            \bv{null}     &0     &1     &0     &0     &\cdots&0\cr
            \bv{symbol}     &1     &1     &1     &0     &\cdots&0\cr
            \bv{string}     &0     &0     &0     &1     &\cdots&0\cr
            \vdots  &\vdots&\vdots&\vdots&\vdots&\ddots&\vdots\cr
            \bv{list}     &0     &1     &0     &0     &\cdots&1\cr
          }
        \]

        \onslide<9>
        \[
          \bordermatrix{
            &\repr{t}&\repr{nil}&\repr{sym}&\repr{"str"}&\cdots&\repr{\scriptsize(l i s t)}&\repr{\scriptsize:true}&\repr{\scriptsize:false}&\repr{\scriptsize:null}\cr
            \bv{nil}     &0     &0     &0     &0     &\cdots&0&0&0&0\cr
            \bv{t} &1     &1     &1     &1     &\cdots&1&1&1&1\cr
            \bv{null}     &0     &1     &0     &0     &\cdots&0&0&0&0\cr
            \bv{symbol}     &1     &1     &1     &0     &\cdots&0&1&1&1\cr
            \bv{string}     &0     &0     &0     &1     &\cdots&0&0&0&0\cr
            \vdots  &\vdots&\vdots&\vdots&\vdots&\ddots&\vdots&\vdots&\vdots&\vdots\cr
            \bv{list}     &0     &1     &0     &0     &\cdots&1&0&0&0\cr
            \bv{MEMBER}&0     &0     &0     &0     &\cdots&0&1&1&1\cr
          }
        \]
      \end{overprint}
    \end{macosbox}
  \end{popup}
\end{frame}

\begin{frame}[fragile]
  \frametitle{\code{employee} verification}
  \begin{columns}
    \column{.65\textwidth}
\begin{hlclcode}
(defclass employee ()
  ((name :type (or string
                   (and symbol
                        (not keyword))
                   unsigned-byte))
   (half-time-p (or boolean
                    (member :true
                            :false))))
  (:metaclass json-serializable))
\end{hlclcode}

\begin{hlclcode}
(subtypep '(or string
               (and symbol
                    (not keyword))
               unsigned-byte)
          'json)
\end{hlclcode}

    \column{.35\textwidth}
    \begin{itemize}
    \item<3->[\good] \code{employee.name}
      % \begin{itemize}
      % \item \code{null-literal-type-p} \rarr{} \code t
      % \item \code{null-numeric-type-p} \rarr{} \code t
      % \end{itemize}
    \item<4->[\alt<4>{\color{watchOS-purple}\faQuestion}{\good}] \code{employee.half-time-p}
      % \begin{itemize}[<+->]
      % \item \code{boolean} $\equiv$ \code{(member t nil)}
      % \item \code{t}, \code{nil}, \code{:true}, \code{:false} \rarr{} alrady
      %   registered
      % \item \code{null-literal-type-p} \rarr{} \code t
      % \item \code{null-numeric-type-p} \rarr{} \code t
      % \end{itemize}
    \end{itemize}

    \pause
    \bigskip
    \only<6>{%
      \begin{exampleblock}{Conclusion}
        \code{employee} is JSON-compatible! \emoji{ðŸŽ‰}
      \end{exampleblock}}
  \end{columns}


  \begin{popup}{.7}
    \vspace*{-2em}
    \onslide<2>
    \begin{mintedcodebox}[headless,compact]
\begin{minted}[fontsize=\scriptsize]{cl}
(and (NULL-LITERAL-TYPE-P '(AND (or string
                                    (and symbol
                                         (not keyword))
                                    NIL)
                                (NOT (or NIL
                                         string
                                         (member :true :false :null)
                                         (and symbol
                                              (not keyword))
                                         list
                                         hash-table))))
     (NULL-NUMERIC-TYPE-P '(AND (or NIL
                                    (and NIL
                                         (not NIL))
                                    unsigned-byte)
                                (NOT (or number
                                         NIL
                                         NIL
                                         (and NIL
                                              (not NIL))
                                         NIL
                                         NIL)))))
\end{minted}
    \end{mintedcodebox}
  \end{popup}
\end{frame}

\begin{sectionframe}{Going further}
  CLOS classes, representation conflicts \& \code{null-numeric-type-p}
\end{sectionframe}

\begin{frame}
  \frametitle{CLOS classes}
  \setbeamercovered{highly dynamic}

  \begin{itemize}
  \item Issue \rarr{} find a representative instance
  \item Cannot use \code{make-instance} \rarr{} possible side-effects
    \pause
  \item Baker's solution
    \begin{itemize}
    \item \emph{hook into \code{defclass}/\code{defstruct} implementation}
    \item[\tiny\minus] not portable
    \item[\tiny\minus] maybe not trivial
    \end{itemize}
  \end{itemize}

  \pause

  \begin{itemize}
  \item Our solution \rarr{} the Meta Object Protocol
    \begin{itemize}
    \item \emph{register class prototypes \rarr{} ``fake'' instances}
    \item[\tiny\plus] portable
    \item[\tiny\plus] easier to implement
    \item[\tiny\plus] packageable
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Representation conflicts}
  TODO?
\end{frame}

\begin{frame}
  \frametitle{\code{null-numeric-type-p}}
  \begin{itemize}
  \item Many representations of numerical data types
  \item Range representation available \rarr{} \code{(integer (12) *)}
  \item Exponential theoretical complexity
    \begin{itemize}
    \item acceptable in practice
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[standout]
  \frametitle{Conclusion}
  \begin{itemize}
  \item A
  \item B
  \item \alt<2>{\sout{More efficient} April fools}{More efficient}
  \end{itemize}
\end{frame}

\begin{sectionframe}{\it Thanks for listening! \emoji[\normalsize]{ðŸ˜ƒ}}
  \it Any question?
\end{sectionframe}

\end{document}
