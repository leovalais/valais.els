\documentclass[format=sigconf]{acmart}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage{varioref}   %
\usepackage{hyperref}
\usepackage[nameinlink,capitalize]{cleveref}
\usepackage{tocloft}
\usepackage{amsthm} % example env
\usepackage{enumitem} % description env
\usepackage{tikz}

\newcommand\asterism{\medskip\noindent\textcolor{black!65}{\small\centerline{$\phantom{x}_{*\,\,\,*}^{\,\,\,*}$}}\smallskip}
\newcommand\intvl[1]{\llbracket#1\rrbracket}

\usemintedstyle{xcode}
\newminted{cl}{autogobble,breaklines,escapeinside=||,fontsize=\small}

\newcommand\code[2][\small]{\sloppy\texttt{#1#2}}
\newcommand\footcode[1]{\code[\scriptsize]{#1}}

\theoremstyle{definition}
\newtheorem{example}{Example}

\usetikzlibrary{positioning,shapes,shadows}


\bibliographystyle{alpha}

\acmConference[ELS'19]{the 19th European Lisp Symposium}{April 01--02 2018}{Genova, Italy}
\acmISBN{978-2-9557474-2-1}
\acmDOI{}

\title{Implementing Baker's SUBTYPEP decision procedure}

\author{LÃ©o Valais}
\email{lvalais@lrde.epita.fr}
\orcid{0000-0000-0000-0000}

\author{Jim E. Newton}
\email{jnewton@lrde.epita.fr}
\orcid{0000-0002-1595-8655}

\author{Didier Verna}
\email{didier@lrde.epita.fr}
\orcid{0000-0002-6315-052X}

\affiliation{%
  \institution{EPITA/LRDE}
  \streetaddress{14-16 rue Voltaire}
  \postcode{94270}
  \city{Le Kremlin-Bic{\^e}tre}
  \country{France}
}

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003790.10011740</concept_id>
<concept_desc>Theory of computation~Type theory</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003752.10003809.10011254.10011257</concept_id>
<concept_desc>Theory of computation~Divide and conquer</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10003752.10003809.10010031.10010032</concept_id>
<concept_desc>Theory of computation~Pattern matching</concept_desc>
<concept_significance>100</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[300]{Theory of computation~Divide and conquer}
\ccsdesc[100]{Theory of computation~Pattern matching}


\newcommand\sbcl{\textsc{Sbcl}}
\newcommand\then{$\rightarrow$}

\begin{document}


% \toappear{}
\begin{abstract}
  The Common Lisp standard allows the function \code{subtypep} to return
  the couple of values \code{(nil nil)} when it cannot determine the
  sub-typing relationship between two types. That permission to fail
  is granted because the type system allows the usage of the type specifier
  \code{(satisfies P)}, understood as the type containing all the
  elements for which the predicate \code{P} return $\top$. Since \code{subtypep}
  must not evaluate \code{P}, it cannot answer many interrogations involving
  such a type specifier---hence the permission to fail. Implementations of the
  predicate often abuse such permission, making the function both inaccurate and
  unreliable. That behavior is troublesome for some applications, in particular
  for the compiler itself which uses \code{subtypep} for optimization purposes.
  Seeking for precision, H. Baker describes a decision procedure which he claims
  to be more accurate and efficient than the average implementation.
  In this article we present our partial implementation of his procedure, detail
  our understanding of his algorithm, argument in favor or against some of
  his choices and clarify parts of his description.
\end{abstract}

\maketitle

\section{Introduction}
The Common Lisp standard \cite{bib:ansi.94.cl} provides the predicate function
\code{subtypep} for
introspecting the sub-typing relationship. Every invocation \code{(subtypep A B)}
either returns the values \code{(t t)} when \code{A} is a sub-type of \code{B},
\code{(nil t)} when not or \code{(nil nil)} meaning the predicate could not
(or failed to) answer the question. The latter can happen when the type
specifier \code{(satisfies P)} (representing the type $\{x \mid
\mathtt{P(x)}\}$ for some predicate and total function\footnote{A function
  defined over its entire definition domain.} \code{P}) is involved. For example,
there is indeed no way for the function to answer anything else than \code{(nil
  nil)} for any arbitrary predicates \code{F} and \code{G} to the question
\code{(subtypep '(satisfies F) '(satisfies G))}.

However some implementations abuse of the permission to return \code{(nil nil)}.
For example, in \sbcl{} (the implementation we are currently focusing our
efforts on), {\small\code{(satisfies 'boolean 'keyword)}} returns
\code{(nil nil)}, thus violating the standard\footnote{The Common Lisp standard
  requires that no invocation of \footcode{subtypep} involving only primitive types
  returns \footcode{(nil nil)}.}. The definition of the \code{keyword} type is
responsible for the failure: as shown in \vref{lst:keyword}, it
involves a \code{satisfies} type specifier. Therefore any type-based
optimization involving determining whether \code{boolean} is a sub-type of
\code{keyword} is lost.

Another kind of problem for which \code{subtypep}'s accuracy matters is the
optimization of the \code{typecase} construct as shown in \cite{newton.18.phd}
and \cite{newton.18.els}. The aim is to remove redundant checks in the construct
and their approach is to use binary decision diagrams. However, to build such a
structure, \code{subtypep} is repeatedly used. The unreliability of the
predicate leads here to many lost BDD reductions and therefore to the
generation of sub-optimal code.

Our implementation is still in active development, currently targets
\sbcl{} and focuses almost entirely on results accuracy. It supports
\emph{primitive} types, \emph{user-defined} types (\code{deftype}, classes and structures),
\emph{\code{member} (and \code{eql})} type specifiers and \emph{ranges} (e.g.,
\code{(integer * 12)}). We will present our strategy for implementing each one
of these while discussing how and why we decided or not to diverge from Baker's
\cite{baker1992}
approach---or potentially filling some gaps or unclear bits.
No optimization work has been done yet and the implementation still has
bugs and diverse issues but we have found some encouraging results about
accuracy and even about efficiency.

\begin{listing}[!p]
  \begin{clcode}
(sb!xc:deftype keyword ()
  '(and symbol (satisfies keywordp)))
  \end{clcode}
  \caption{The \code{keyword} type definition in \sbcl}
  \label{lst:keyword}
\end{listing}


\section{The Common Lisp type system}
\subsection{Type specifiers}
We can equivalently speak of types and sets and Common Lisp types are no
exception. They are not manipulated directly. Instead, the type to be
manipulated is \emph{described} using a \emph{type specifier}.
The type specifier DSL (Domain-Specific Language) allows the programmer to
describe types by writing S-expressions which obey some rules described in the
Common Lisp standard \cite{bib:ansi.94.cl} and roughly summarized by the
\vref{tab:ts}\footnote{More type specifiers exist. We do not describe them either
  because they are not implemented or because Baker's procedure ignores them as well.}.

A subtlety about this mechanism is that \emph{different type specifiers} can
represent the same type (e.g., \code{integer}, \code{(integer * *)} and
\code{(or fixnum bignum)} all describe the same type). It means that
\emph{symbolic computation does not suffice} to answer the sub-typing question.
As shown in \vref{lst:type=}, one could write a predicate, say \code{type=}, to
determine whether two type specifiers describe in fact the same type using
\code{subtypep}.

It is possible to define \emph{parametric aliases} using the \code{deftype}
construct. It is then possible to refer to a whole type specifier using its
alias. The \vref{lst:deftype} shows an example of parametric \code{deftype}.

\begin{listing}
\begin{clcode}
(defun type= (type1 type2)
  (multiple-value-bind (res1 sure1-p)
      (subtypep type1 type2)
    (multiple-value-bind (res2 sure2-p)
        (subtypep type2 type1)
      (values (and res1 res2)
              (and sure1-p sure2-p)))))
\end{clcode}
\caption{The predicate \code{type=}}
\label{lst:type=}
\end{listing}

\begin{listing}
\begin{clcode}
(deftype except (x)
  `(not (eql ,x)))
\end{clcode}
\caption{The \code{deftype} construct}
\label{lst:deftype}
\end{listing}

\begin{table*}
  \centering
  \newcommand\var[1]{{\color{gray}$#1$}}
  \newcommand\pat[1]{\texttt{\small #1}}
  \begin{tabular}{rl|c}
    \hline
    Type specifier pattern & Description & Example \\
    \hline
    \pat{nil} & The null type $\emptyset$ & --- \\
    \pat{\var{t}}
            & A \code{symbol}-designated type & \code{character} \\
    \pat{(eql \var{e})}
            & The singleton type $\{e\}$ & \code{(eql 12)} \\
    \pat{(member \var{e_1} $\cdots$ \var{e_n})}
            & The type $\{e_1, \cdots, e_n\}$ & \code{(member t nil)} \\
    \pat{(not \var{t})}
            & The complement type $\overline{t}$ & \code{(not null)} \\
    \pat{(or \var{t_1} $\cdots$ \var{t_n})}
            & The union type $t_1 \cup \cdots \cup t_n$ & \code{(or integer float)} \\
    \pat{(and \var{t_1} $\cdots$ \var{t_n})}
            & The intersection type $t_1 \cap \cdots \cap t_n$ & \code{(and symbol (not keyword))} \\
    \pat{(\var{t} \var{X} \var{Y})}
            & The range $\{n \in t \mid X \leq n \leq Y\}$ & \code{(integer 1 6)} \\
    \pat{(\var{t} (\var{X}) \var{Y})}
            & The range $\{n \in t \mid X < n \leq Y\}$ & \code{(integer (0) 6)} \\
    \pat{(\var{t} * (\var{Y}))}
            & The range $\{n \in t \mid n < Y\}$ & \code{(integer * (43))} \\
    \pat{(array \var{t} \var{n})}
            & $n$-dimensional array of elements of type $t$ & \code{(array integer 1)} \\
    \pat{(array * (\var{d_1} $\cdots$ \var{d_n}))}
            & Array with $d_i$ elements in its $i$-th dimension & \code{(array * (3 3))} \\
    \pat{(array \var{t} (* * *))}
            & 3-dimensional $t$ array & \code{(array symbol (* * *))} \\
    \pat{(satisfies \var{p})} & The type $\{x \mid p(x)\}$ & \code{(satisfies oddp)} \\
    \hline
  \end{tabular}
  \caption{Brief summary of the type specifier DSL features}
  \label{tab:ts}
\end{table*}

\subsection{Vocabulary}
Follows some vocabulary, notations and conventions used in this article.

\begin{description}[leftmargin=8em,style=nextline]
  \item[type] For any type $t$: $t \equiv \{x \mid x\!:\!t\}$
  \item[canonical t.s.] A type specifier without aliases.
  \item[primitive type] A standardized type that is not necessarily
    implemented as a class.
  \item[symbolic form] A type specifier which type is \code{symbol}.
  \item[compound form] A type specifier which type is \code{list}.
  \item[logic type] A top-level union, intersection or complement.
  \item[literal type] A type specifier that only contains symbolic types,
    \code{member} types and logic compound forms.
  \item[interval] A mathematical interval that may not be a valid type specifier.
  \item[range type] A type specifier that only contains ranges and logic compound forms.

  \item[type $\approx$ t.s.] When no confusion is possible we take the right to
    write type specifiers where a mathematical type is expected and to use a type
    variable, say $T$, as a placeholder inside Lisp code for \emph{a type
      specifier describing} $T$.
  \item[$T \subseteq T'$] The \emph{type} $T$ is a non-strict sub-type of $T'$.
    We always have \code{(subtypep $T$ $T'$)}.
\end{description}

\section{General procedure flow}
\label{sec:flow}
\vref{fig:flow} pictures the internals of our implementation. Every step will be
detailed in the following sections. There are three \emph{major stages}:

\begin{enumerate}
\item \emph{The pre-processing} --- Both type specifiers are processed in order to
  simplify further calculations: the aliases are expanded, each occurrence of
  numeric types are converted to their equivalent range type specifier and the
  type specifier is finally split. This stage is detailed in % section
  \vref{sec:pre}.
\item \emph{Expert sub-procedures} --- Once split, each sub-type specifier is
  redirected to the appropriate expert sub-procedure. Such procedures' job is to
  determine, in its own \emph{kingdom} in Baker's terminology, whether or not it
  can \emph{prove} the assertion ``$A$ is a sub-type of $B$'' to be \emph{wrong}.
  Our procedures currently only supports literal and range type specifiers---an
  expert sub-procedure has been implemented only for these two kingdoms. This
  stage is detailed in \vref{sec:exp}.
\item \emph{Result accumulation} --- Eventually, all expert sub-procedures
  return (a Boolean) and the results are accumulated using conjunction.
\end{enumerate}

\begin{figure}
  \centering
  \input{assets/19/flow}
  \caption{Internal flow for \code{(subtypep $A$ $B$)}}
  \label{fig:flow}
\end{figure}

\section{Pre-processing}
\label{sec:pre}
\subsection{Alias expansion}
The very first step is to ensure that the type specifier is in its
\emph{canonical form}, that is, having all its aliases expanded. For example,
considering the type created in \vref{lst:deftype},
\code{(expand '(except 12))} should return \code{(not (eql 12))}.

Unlike for the macro expansion, the \code{deftype} expansion is not
standardized. Thus a solution must be found for each implementation
independently. As our efforts are focused on \sbcl{} (yet), we discuss how we
implement the \code{expand} function for that compiler.

\sbcl's \code{subtypep} heavily relies on the function
\code{sb-kernel:specifier-type}, which does type expansion. It also does
type simplification---turning \code{(and integer string)} into
\code{nil}---which could have saved us some work. We hoped we could simplify
that function to make it compatible with Baker's algorithm while keeping the
\code{deftype} expansion and the range canonicalization work. However we found,
thanks to \cite{newton.18.phd} tools, that the function is responsible for most
of the work of \code{subtypep}, as shown in \vref{fig:specifiertype}
\footnote{The \footcode{cached-subtypep-caching-call} is just a memoizing wrapper
  around \sbcl's \footcode{subtypep} which is a bit more efficient than the raw
  implementation}.
Considering the lack of efficiency of that function and the fact that it would
not be trivial to simplify it to only keep the interesting bits, we decided to
stick to another, more cost-effective solution.

The function \code{sb-ext:typexpand} takes a type specifier and tries to expand
it (not recursively) and either returns the expansion result or the input type
specifier if it is not expandable. \code{(sb-ext:typexpand 'integer)} returns
\code{integer} since it is not a \code{deftype} alias whereas
\code{(sb-ext:typexpand '(except 12))} returns \code{(not (eql 12))}.
To expand a whole type specifier, it just needs to go through it, applying
\code{sb-ext:typexpand} on each list or atom. One subtlety though is that the
result of an expansion may itself be an alias to expand\footnote{Fortunately,
  \footcode{sb-ext:typexpand} also returns a Boolean indicating whether or not
  an expansion happened.}.

\newcommand\ststpscale{0.5}
\begin{figure}
  \centering
  \includegraphics[scale=\ststpscale]{assets/19/stGTstp}
  \includegraphics[scale=\ststpscale]{assets/19/stEQstp}
  \caption{\code{specifier-type} weight in \code{subtypep} execution}
  \label{fig:specifiertype}
  % \label{fig:stGTstp}
\end{figure}
%% NOTE perhaps separate the images in two distinct figures
% \begin{figure}
%   \centering
%   \includegraphics[scale=\ststpscale]{assets/19/stEQstp}
%   \caption{\code{specifier-type} weight in \code{subtypep} execution}
%   \label{fig:stEQstp}
% \end{figure}

\subsection{Numeric type specifiers conversion}
\label{sec:numconv}
As explained in \vref{sec:flow}, after pre-processing both type specifiers, the
procedure splits in two expert sub-procedures: one for literal type specifiers
and one for range type specifiers, because their internal representation differ.
Numeric types---types containing numbers (mathematically speaking)---can have
different representations: a \emph{symbol} (e.g., \code{fixnum}), a \emph{range}
(e.g., \code{(integer 1 6)}) or a \emph{\code{member} expression}
(e.g., \code{(member 1 2 3)}). However, the first two are literal where le
latter is a range. Thus, the numerical type information would be distributed in
the different expert sub-procedures (which does not share any data). For
consistency's sake and to obtain accurate results, a single internal
representation should be chosen. The symbolic and \code{member} numeric types
must then be converted into an equivalent type specifier involving only ranges
to describe numerical data.

\begin{itemize}
\item \emph{Symbolic} numeric type specifier --- say \code{U}, replace it by
  \code{(U * *)}\footnote{Implementations supporting the IEEE floating point
    raise many concerns with \footcode{-0.0}, $NaN$, $+\infty$ and $-\infty$.
    Baker explains in detail how to handle these cases, which our implementation
    (FIXME is that assertion totally true?)
    does not support yet.}. Note the new ``type specifier'' is likely
  \emph{not} to be valid (e.g., \code{(fixnum * *)} is invalid).
\item \code{member} type specifiers --- e.g., \code{(member a 1 2 :b)} is
  converted to \code{(or (member a :b) (bit 1 1) (integer 2 2))}.
  To do that,
  \begin{enumerate}
  \item extract the numbers out of the expression,
  \item map each number, say $n$, to construct the type specifier
    \code{((type-of $n$) $n$ $n$)}\footnote{\footcode{type-of} sometimes
      returns a list which \footcode{car} is the type of the range.},
  \item and combine the remaining \code{member} expression and the ranges with
    the \code{or} logic type specifier.
  \end{enumerate}
\end{itemize}

A subtlety to consider is that \textit{super-types} of \code{number} also
contain numerical data that must be extracted. Indeed, the type specifier
\code{atom} contains both numerical data---\code{(number * *)}---and non-numerical
data---\code{(and atom (not (number * *)))}. Unfortunately the latter
expression cannot be used since it uses the \code{atom} type specifier and
recursively converting that replacement would result in a infinite computation
loop. Thus \code{atom} must first be replaced by its sum type representation,
that is \code{(or stream array character function standard-object symbol
  structure-object structure-class (number * *))} before being recursively
converted. Similarly, the other super-type of \code{number}, the type \code{t}
must be replaced by \code{(or atom sequence)}.

Yet another subtlety is that the type specifiers \code{(and)} and
\code{(or)} respectively describe the types \code{t} and \code{nil}. Hence
every occurrence of \code{(and)} must be replaced by the replacement of
\code{t} described in the last paragraph. In order to remove that annoying
corner case completely, \code{(or)} is also replaced (by \code{nil}).

\subsection{Splitting}
Reached this step, the input only contains \emph{canonical} \emph{literal} and
\emph{range} type specifiers, numeric types being \emph{only} expressed as
ranges. The next stage---expert sub-procedures---requires literal and numeric
types to be separated.

Thus the top type \code{t} is divided into two\footnote{
  One per kingdom actually, but since out implementation only support
  two---literal and range types---we only focus our attention these.
} disjoint sub-types---``kingdoms'' as Baker says. The last step, described in
\vref{sec:numconv}, ensures the representation (in term of type specifiers) of
the types in each kingdom is different. All numeric types are represented as
ranges and literal types are represented as symbolic and \code{member} (without
numbers) type specifiers.

This step roughly consists in an in-depth traversal of the type specifier, using
pattern-matching to recognize which type specifier represents which type. We use
the implementation of \cite{bib:norvig.92.paip} for its simplicity and versatility.

Our implementation uses a function \code{type-keep-if} which takes a predicate
$P$ and a type specifier $T$ and returns:
\begin{itemize}
  \newcommand\mcode[1]{\text{\code{#1}}}
\item $T$ as it is when $P(T) = \top$,
\item \code{nil} when $P(T) = \bot$,
\item \code{($op$ $U_1$ $\cdots$ $U_n$)}
  where \(U_i = \mcode{(type-keep-if $P$ $T_i$)}\)
  when \(T = \mcode{($op$ $T_1$ $\cdots$ $T_n$)}\)
  and $op \in \{\mcode{and}, \mcode{or}, \mcode{not}\}$.
\end{itemize}
This function, given the predicate \code{literal-type-p} and a type $T$, returns
$T$ with every inner type specifier that describes a non-literal type
replaced by \code{nil} (interpreted as the \textit{empty type}). The result is then a
sub-type of \code{(and t (not number))}.
Likewise, given the predicate \code{range-type-p}, this function returns $T$
with every non-range inner type specifier replaced by \code{nil} (interpreted
this time as the \textit{empty range}). Thus the result is a sub-type of \code{number}.
Therefore, \code{split} can easily be implemented in terms of
\code{type-keep-if}, as shown in \vref{lst:split}.

\begin{listing}
\begin{clcode}
(defun split (type)
  (list (type-keep-if #'literal-type-p type)
        (type-keep-if #'range-type-p type)))
\end{clcode}
\asterism
\begin{clcode}
SLIME> (split 'symbol)
;; (SYMBOL NIL)
SLIME> (split '(ratio * *))
;; (NIL (RATIO * *))
SLIME> (split  '(and (or symbol (float * *) (ratio * *))
                     (not (not (number * *)))))
;; ((AND (OR SYMBOL NIL NIL) (NOT (NOT NIL)))
;;  (AND (OR NIL (FLOAT * *) (RATIO * *))
;;       (NOT (NOT (NUMBER * *)))))
\end{clcode}
\caption{The \code{split} function}
\label{lst:split}
\end{listing}

\subsection{Type unification}
According to theory, for any types $T$ and $U$,
\(T \subseteq U \Leftrightarrow T \cap \overline{U} = \emptyset\).
Therefore, for any type specifiers \code{U} and \code{V}, when
\code{(subtypep U V)} returns \code{T T}, then
\code{(subtypep `(and ,U (not ,V)) nil)} also returns \code{T T}.

The results of the \code{split} function are zipped together using
\code{(lambda (x y) `(and ,x (not ,y)))} before being passed to the expert
sub-procedures. This way, they will not have to prove that an arbitrary type is a
sub-type of \emph{another} arbitrary sub-type, but rather whether \emph{one}
arbitrary type specifier describes the empty type (which is substantially
easier to reason about and implement).

\section{Expert sub-procedures}
\label{sec:exp}
\vref{lst:tdstp} shows how \code{subtypep} could be defined from a top down
point of view. It shows that, according to \vref{fig:flow}, both type
specifiers are processed independently, split into two kingdoms (literal and
numeric types) and unified in an \code{(and U (not V))} fashion. The
expert sub-procedures, \code{literal-type-nil-p} and \code{numeric-type-nil-p},
each accept one argument---a type specifier, say $T$---and returns a Boolean
indicating whether $T$ describes the empty type (\code{nil}).

Each sub-procedure answers inside its kingdom. There are two kingdoms supported
by our implementation:
\begin{itemize}
\item \emph{literal types} --- at most the type described by \code{(and (not
    number) (not (array * *)))}\footnote{
    Actually this is not completely accurate since the type \footcode{string}
    can be described using array type specifiers. However, since the latter is
    not supported by our implementation yet, we consider the types
    \footcode{string} and \footcode{bit-vector} being literal types since their
    symbolic representation is kept through the entire process. This is very
    likely to change in the future.
    }, only expressed as symbolic and \code{member} type
  specifiers.
\item \emph{numeric types} --- at most the type described by \code{number}, only
  expressed using interval type specifiers.
\end{itemize}

There are several properties that are derived from the precedent pre-processing
steps. First of all, both kingdoms' procedures are guaranteed to receive as
argument \emph{canonical} type specifiers only. These are also guaranteed not to
contain \code{atom} or \code{t} type specifiers. The occurrences of \code{(and)}
and \code{(or)} have been replaced respectively by \code{t} and \code{nil}.
\code{eql} type specifiers have been replaced by equivalent \code{member} expressions.
\code{member} type specifiers only occur in the literal type kingdom and contain
no numerical data. Numerical data are only expressed as intervals, which are likely
not to be valid type specifiers. Both kingdoms accept the type specifier
\code{nil} but with a \emph{different meaning}: for literal types, \code{nil}
means the empty type which complement is \code{t} whereas for numeric types it
represent the empty range witch complement is \code{(number * *)}.

In the following sections we describe in detail the implementation of the expert
sub-procedures for the literal (\vref{sec:explit}) and numeric
(\vref{sec:expnum}) type kingdoms. We also briefly discuss
about the array type kingdom and the \code{cons} type specifier family,
which Baker ignores in his article, in \vref{sec:expoth}.

\begin{listing}
\begin{clcode}
(defun subtypep (a b)
  (reduce (lambda (x y) (and x y))
          (mapcar (lambda (expert t1 t2)
                    (funcall expert `(and ,t1 (not ,t2))))
                  (list #'literal-type-nil-p
                        #'numeric-type-nil-p)
                  (split (num-types->ranges (expand a)))
                  (split (num-types->ranges (expand b))))))
\end{clcode}
\caption{A top-down approach of \code{subtypep}}
\label{lst:tdstp}
\end{listing}

\subsection{Procedure for literal types}
\label{sec:explit}
\subsubsection{Concept}
To represent types in the literal types kingdom, we suppose at first that there
is way to enumerate every element in \code{t}, say $e_1, e_2, \dots, e_\omega$.
Then, let $t_1, t_2, \dots, t_\omega$ be all the (non-strict) sub-types of the
top-level type \code{t}. We associate to each pair $\left(t_i, e_j\right)$ the
bit $b_{ij}$ with the value $1$ when $e_j \in t_i$ and $0$ when $e_j \notin t_i$.
Let $bv_i$ be the \emph{representative bit-vector} associated to the type $t_i$,
defined by $\left[b_{i0}, b_{i1}, \dots, b_{i\omega}\right]$. These
bit-vectors are the rows of the infinite matrix on \vref{eq:matrix} which
illustrates the system.

\[
  \bordermatrix{
            &e_1   &e_2   &e_3    &e_4    &\cdots&e_\omega \cr
    t_1     &1     &0     &0      &0     &\cdots&1       \cr
    t_2     &0     &1     &1      &0     &\cdots&0       \cr
    t_3     &0     &0     &0      &1     &\cdots&0       \cr
    \vdots  &\vdots&\vdots&\vdots&\vdots&\ddots&\vdots  \cr
    t_\omega&1     &0     &1      &0     &\cdots&0
  } \label{eq:matrix} \tag{$B_{\omega\omega}$}
\]

\begin{proof}
  \emph{\small Each type has a unique bit-vector representation.}
  \newcommand{\reldiff}[2]{#1 \cup #2 \backslash #1 \cap #2}

  Let $t_i$ and $t_j$ two distinct types. Thus, $\reldiff{t_i}{t_j} \neq \emptyset$.
  Let $e_k \in \reldiff{t_i}{t_j}$. By definition, we have $b_{ik} \neq b_{jk}$.
  Hence $bv_i \neq bv_j$. Two distinct types are represented by two different
  bit-vectors.

  Similarly, let $bv_i$ and $bv_j$ be two different bit-vectors. Then it
  necessarily exists a $k$ such as $b_{ik} \neq b_{jk}$. Therefore
  $\exists e_k, \left(e_k \notin t_i \vee e_k \notin t_j\right) \wedge e_k
  \notin t_i \cap t_j$. Hence $t_i \neq t_j$. \qedhere
\end{proof}

\begin{proof}
  \emph{\small Type intersection, union and complement are equivalent to Boolean
    operations ``and'', ``or'' and ``not'' on representative bit-vectors.}

  Let two types $t_i$ and $t_j$ in:
  \begin{enumerate}
  \item Let $t_k = t_i \cup t_j$. By definition, $\forall l \in \mathbb{N} \cup
    \{\omega\}, b_{kl} = 1$ iff $b_{il} = 1$ or $b_{jl} = 1$, that is $b_{kl} =
    b_{il} \vee b_{jl}$. Thus, also by definition:
    \begin{align*}
      bv_k &= \left[b_{k0}, b_{k1}, \dots, b_{k\omega}\right]  \\
           &= \left[b_{i0} \vee b_{j0}, b_{i1} \vee b_{j1}, \dots, b_{i\omega} \vee b_{j\omega}\right]  \\
           &= bv_i \vee bv_j
    \end{align*}
  \item We proceed similarly for the intersection and the Boolean logic operator
    ``and'' ($\wedge$).
  \item Let $t_k = \overline{t_i}$. We have by definition $\forall l \in
    \mathbb{N} \cup \{\omega\}, b_{kl} = \neg b_{il}$. Then:
    \begin{align*}
      bv_k &= \left[\neg b_{i0}, \neg b_{i1}, \dots, \neg b_{i\omega}\right]  \\
           &= \neg bv_i \qedhere
    \end{align*}
  \end{enumerate}
\end{proof}

On each \code{literal-type-nil-p} call, we lookup each symbolic type
specifiers' (e.g., \code{symbol}) and \code{member} expressions' (roughly
anonymous types) bit-vectors in the matrix, combine these
on each logic type specifier using the appropriate Boolean operation. Finally,
we compare the bit-vector against the bit-vector of \code{nil}, that is
$\left[0, 0, \dots, 0\right]$, and return the result.

\subsubsection{In practice}
Common Lisp cannot enumerate all the possible sub-types of \code{t} nor all of
its elements. Fortunately we do not need them all. We only need to consider the
types present in the input type specifier to determine its emptiness.

It also means that we do \emph{not need to enumerate all the elements of these
  types}. It is that aspect of the procedure of Baker that makes it both
powerful and quite complex to understand at first. We only need \emph{enough}
elements from a type to distinguish it from the other types. Because we are
now considering only a \emph{finite} number of types, say $t_1, \dots, t_n$, to
register a new type $t_{n+1}$ to our (now \emph{finite}) matrix, we only need to
find an element $e \in t_{n+1}$ such as $e \notin t_1 \cup \dots \cup t_n$.

Now let's suppose that $t_{n+1}$'s type specifier is in fact \code{(member
  $e$)}, that $e$ is itself chosen as a representative element for another type,
say $t_k$, and that $t_k$ is only distinguished from the other registered types
by that element $e$. $t_{n+1}$ and $t_k$ would then have the same bit-vector
representation when these types are likely to be distinct. The general solution
for that kind of problem with \code{member} type specifiers is to register
\emph{all} the elements. When there is a conflicting element $e$ already
registered as a representative for another types, we generate additional
representatives for these types. That precaution ensures that this kind of
conflict never happen and simplify greatly the implementation of \code{member}
type specifiers.

\subsubsection{Implementation concerns}
The method for choosing the representative elements for a type depends of its
nature: it can be a primitive type, a user-defined type (class, structure or
condition) or a \code{member} expression.

Since primitive types are known, their representative elements are chosen at
compile-time. The $t_{n+1}$ subtlety above should still be kept in mind. For
instance, the type \code{null} is a sub-type of both \code{symbol} and
\code{list} so three representative elements are needed: \code{nil}, a non-empty
list and a symbol other than \code{nil}. Note that some primitive types are an
\emph{exhaustive partition} of other types (e.g., \code{character}).
Obviously, in that case, such a precaution does not apply.

For user-defined types, Baker suggests to extend the type creation mechanism to
register a dummy element as a representative. We decided \emph{not} to follow
his approach because of the poor portability of his solution. Indeed, this
work, often non-trivial, would have to be repeated for each targeted Common Lisp
implementation. Moreover, it would register a representative for \emph{every}
class created, thus increasing bit-vectors' size uselessly since only a few of
these classes are likely to appear in a \code{subtypep} type specifier.
We decided instead to use the \emph{Meta Object Protocol} (\textsc{Mop})
\cite{bib:kiczales.91.book}, more specifically \emph{class prototypes}. Class
prototypes are pseudo-instances of a class, created without executing
\code{initialize-instance} and which \code{typep} and \code{eql} view as traditional
instances. However, to create a class prototype, the class needs to be
\emph{finalized} and it cannot be guaranteed until it is instantiated.
Since that class may be involved in a \code{subtypep} call before that happens,
when a new class is encountered, we force its finalization using the function
\code{ensure-finalized} from the (portable) \code{closer-mop} package.
Then, we create the prototype of the class using \code{sb-mop:class-prototype}
and register it. This method is much more portable than Baker's and does not
require to hook inside the implementation. In \sbcl{} and other major Common
Lisp implementations, structures and conditions are implemented as classes so no
additional work is required. But that solution is not fully portable either.

Each time a \code{member} type specifier is encountered, we must ensure that we
generate a new representative element whenever we try to register a
\code{member} element already registered. The Common Lisp standard
\cite{bib:ansi.94.cl} states that the \code{member} type specifier is defined in
terms of \code{eql}. That is, \code{(typep $e$ '(member $e_1$ $\cdots$ $e_n$))}
uses \code{eql} to compare $e$ to the successive $e_k$ to check the membership.
Fortunately, within the literal types kingdom, the only problematic types are
\code{character} and \code{symbol} since the representatives are not supposed to
be accessible to the user of \code{subtypep}. (E.g., the representative of the
type \code{list} \code{(1 2 3)} is not \code{eql} to the list inside
\code{(member (1 2 3))}.) Therefore, only the representatives of these types
need to be actually checked when registering \code{member}'s elements.
To generate a new symbol, we use \code{alexandria:symbolicate}.
(The \code{keyword} sub-type of symbol is also subject to the problem.)
To generate a new character, we first need to know whether it is a
\code{base-char} or an \code{extended-char}. Then we pick a character of that
type not registered yet. When all the characters of that type are registered
there is nothing to do (since the type is fully represented in the matrix, no
misinterpretation can occur). We have not addressed the problem of a type
specifier involving a user class $C$ and a \code{member} expression containing
the class prototype of $C$ yet.

To implement that registration matrix system, we use two functions:
\sloppy${B : \text{type name} \longmapsto \text{bit-vector}}$,
with $B(t_i) = bv_i$, and
\sloppy${I : \text{representative} \longmapsto \text{bit index}}$,
with $I(e_i) = i - 1$.
Baker suggests in his small example \cite{baker1992} using the operator
\code{set} which is deprecated in modern Common Lisp programming. Instead, we
use hash tables to represent these functions. Type names are \code{symbol}s,
bit-vectors are \code{bit-vector}s and element indexes are positive
\code{integer}s. To register a new type $t_{n+1}$, it is added to the $B$ hash
table and its bit-vector content $b_{(n+1)i}$ is evaluated for all the existing
representatives ($i \in \intvl{1;m}$). To register a new representative
$e_{m+1}$, it is added to the $I$ hash table with the index $m$. Then we add one
bit (the $m$-th bit) to each bit-vector $bv_i$ and evaluate it in respect to the
type $t_i$. Thus, to retrieve the bit-vector of a registered primitive or
user-defined type $t$, we just lookup its value $B(t)$. To compute the
bit-vector of a \code{member} expression \code{(member $e_1$ $\cdots$ $e_n$)},
we use the value $\bigvee_{i=1}^n \beta\left(I\left(e_i\right)\right)$, where
$\beta(x)$ returns the null 0-based bit-vector with the $x$-th bit activated.

% NOTE Perhaps talk about doubling the size of bit-vector instead of adding one
% bit each time.

\subsection{Procedure for numeric types}
\label{sec:expnum}

\subsection{Array types and \code[\large]{cons} type specifiers}
\label{sec:expoth}
This section presents some preliminary work and research results found on array
and \code{cons} type specifiers. Obviously, since the implementation of the
expert sub-procedures for these kingdoms is still a work in progress, no result
nor implementation guidelines are provided here. It does, however, give some
insights about how Baker procedure applies to modern Common Lisp implementations
such as \sbcl.

Array type specifiers are complex to handle because it is bi-dimensional: it
has an element type and bounds (e.g., \code{(array integer (* 2 *))}).
Internally, Common Lisp implementations does not store which exact type
specifier is specified but rather only store the result of the function
\code{upgraded-array-element-type} returns giving that type. E.g, for
\code{(make-array 2 :element-type 'list)}, the implementation does not makes an
array of \code{list} but rather an array of \code{(upgraded-array-element-type
  'list)} = \code{T}. For every type that might return this function, Baker
requires that we store a matrix of bits because of the complex bounds logic of
the type specifier. As for the literal type procedure, it seems to be an
efficient type representation system---albeit more complex---which nonetheless
requires an extra registration step and a global state.

Baker does not mention the \code{cons} type specifier family at all in his
article because it appeared after he released his article \cite{gcl-devel.cons}.
An accurate expert sub-procedure for this kingdom would have an exponential
complexity. More investigation is needed to assert whether or not that
exponential time is ``acceptable'' (as it is for ranges) before rejecting it.
The accuracy of existing \code{subtypep} procedures for the \code{cons} type
specifier also have to be studied.

\section{Conclusion and Future Work}
[..] (Flow programming @SICP)

Even if, in the future, we are to conclude that our implementation is less
efficient than those which already exists, Baker's algorithm would still likely to
improve the predicate's accuracy. Users would then have the ability to
choose whichever \code{subtypep} implementation fits their needs the best.

\bibliography{common}

\end{document}
